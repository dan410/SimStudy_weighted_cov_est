
library(sseigfun) #my package for covariance estimation
library(sfdasim) # my package for simulating spatially distributed curves
library(geoR) # used to simulate gaussian random fields
library(spatstat) # simulating point processes
########################################################
#	create locations
########################################################


### here is a funciton I creadted to make grid point creation easier
grid_points <- function(n, a = 0, b = 1, adj=FALSE){
	if(adj){		
		spc <- (b-a)/(n+1)
		xs <- seq(from=a + spc, to=b-spc, by = spc)
	}else{
		xs <- seq(from=a, to=b, length=n)
	}
	grid.pts <- expand.grid(xs , xs)
	return(grid.pts)
}

### grid1

pts1 <- grid_points(6)
pts1 <- subset(pts1, Var1 > 0.61 | Var2 > 0.61)
pts2 <- grid_points(6, a=0, b=0.6)
plot(pts1, xlim=c(0,1), ylim=c(0,1))
points(pts2, col = "red")
n1 <- nrow(pts1)
n2 <- nrow(pts2)
locs <- rbind(pts1, pts2)
plot(locs, xlim= c(0,1), ylim = c(0,1))
intensity <- c(rep(1, n1), rep(2.78, n2))


### grid 2
pts1 <- grid_points(6)
pts1 <- subset(pts1, Var1 > 0.4 | Var2 > 0.4)
pts2 <- grid_points(6, a=0, b=0.4)
plot(pts1, xlim=c(0,1), ylim=c(0,1))
points(pts2, col = "red")
n1 <- nrow(pts1)
n2 <- nrow(pts2)
locs <- rbind(pts1, pts2)
plot(locs, xlim= c(0,1), ylim = c(0,1), xlab="", ylab="", main="Locations")
intensity <- c(rep(1, n1), rep(4, n2))

### grid 3
pts1 <- grid_points(6)
pts1 <- subset(pts1, Var1 > 0.2 | Var2 > 0.2)
pts2 <- grid_points(6, a=0, b=0.2)
plot(pts1, xlim=c(0,1), ylim=c(0,1))
points(pts2, col = "red")
n1 <- nrow(pts1)
n2 <- nrow(pts2)
locs <- rbind(pts1, pts2)
plot(locs, xlim= c(0,1), ylim = c(0,1),xlab="", ylab="", main="Locations")
intensity <- c(rep(1, n1), rep(25, n2))

nsims <- 50
CURVES <- NULL
for( i in 1:nsims){
	CURVES[[i]] <-  sim_sfda_curves(nBasis=3, 
                            type="Cos", 
														basis.pars = 2,
                            cov.model=rep("exponential",3), 
                            cov.pars=rbind(c(1,.3), c(1,0.3), c(1,0.3)),
                            locs=locs)
}


### calculate intensity at the observed locations to use for weights if locs were generated by a point pattern
# bw = 0.2
# plot(density(sim.pp, sigma = bw))
# intensity <- density(sim.pp, sigma = bw, at="points")[1:n.locs]

### evaluate the true covariance function for comparison
cov.true <- function(x,y){
	alpha = 2
	k <- 1:3
	res <- sum(k^(-2*alpha)*cos(k*pi*x)*cos(k*pi*y))
}

tt <- seq(0,1, length =  20)
grid <- expand.grid(t1 = tt, t2 = tt)
cov.true.pts <- mapply(cov.true, x = grid[,1], y=grid[,2])

### compute L2 distance for each of the estimated covariance functions
dist.L2 <- rep(0, length=nsims)
for( i in 1:nsims){
	mycurves <- CURVES[[i]]
	### generate observed data 
	m <- 5  # number of observations per curve
	times <- seq(0.05,0.95, length = m)
	dat <- with(mycurves, sim_sfda_data(locs = locs, coef = coef, basis.fns = basis.fns, sigma = 0.01, pts = times))
	
	#dat$wt <- 1 # unweighted 
	for( j in 1:length(unique(dat$ID))){
		dat$wt[dat$ID == j] <- (1/intensity[j])^(1/4)
	}
	
	########################################################
	# estimate the covariance function using weights
	########################################################
	cov.est <- estimate_cov_function(dat, n.marginal.knots = 5)
	
	### estimate the L2 distance between estimated cov fun and true cov fun
	tt <- seq(0,1, length =  20)
	grid <- expand.grid(t1 = tt, t2 = tt)
	cov.true.pts <- mapply(cov.true, x = grid[,1], y=grid[,2])
	cov.est.pts <- mapply(sseigfun:::cov.fn, x = grid[,1], y=grid[,2], MoreArgs = list(knots=cov.est$knots, fit.obj=cov.est))
	dist.L2[i] <- sum((cov.true.pts - cov.est.pts)^2)
	
}


wt4 <- dist.L2
boxplot(equal, ylim = c(0,100))
boxplot(list( wt1=wt1,wt2=wt2, wt3=wt3,wt4=wt4, equal=equal), ylim=c(0,100))
boxplot(list(wt.66 = wt.66, wt1 = wt1, wt2=wt2, wt3=wt3, wt4=wt4, equal=equal), ylim=c(0,100))

#strong.dep.pts.med <- list(wt1=wt1, wt2=wt2, wt3=wt3, equal=equal)
#strong.dep.grid3 <- list(wt1=wt1, wt2=wt2, wt3=wt3,wt4=wt4,wt5=wt5, wt6=wt6, equal=equal)
strong.dep.grid1 <- list(wt1=wt1,wt2=wt2, wt3=wt3,wt4=wt4, equal=equal)
save(strong.dep.pts.med, strong.dep.grid3, strong.dep.grid1, file="wtsims.RData")
boxplot(strong.dep.pts.med,ylim=c(0,100), ylab="difference between estimated and true covariance (L2 norm)")






